{
  "permissions": {
    "allow": [
      "Bash(npx create-next-app:*)",
      "Bash(npx create-next-app@latest:*)",
      "Bash(xcopy:*)",
      "Bash(copy:*)",
      "Bash(copy /Y paycopy-temppostcss.config.mjs:*)",
      "Bash(copy /Y paycopy-tempeslint.config.mjs .)",
      "Bash(powershell -Command:*)",
      "Bash(npm install:*)",
      "Bash(node:*)",
      "Bash(\"C:\\\\Users\\\\Herasi\\\\Documents\\\\GitHub\\\\PayCopy\\\\scripts\\\\generate-icons.js\" << 'ENDOFSCRIPT'\n/**\n * generate-icons.js\n *\n * Creates minimal valid PNG files filled with solid orange \\(#ea580c\\)\n * for all required PWA icon sizes. Uses only Node.js built-in modules.\n *\n * PNG structure produced per file:\n *   - 8-byte PNG signature\n *   - IHDR chunk  \\(image header\\)\n *   - IDAT chunk  \\(zlib-compressed image data\\)\n *   - IEND chunk  \\(image end marker\\)\n */\n\nconst fs = require\\('fs'\\);\nconst path = require\\('path'\\);\nconst zlib = require\\('zlib'\\);\n\n// Orange fill colour: #ea580c  -->  R=0xEA  G=0x58  B=0x0C\nconst R = 0xea;\nconst G = 0x58;\nconst B = 0x0c;\n\n// ── helpers ──────────────────────────────────────────────────────────\n\n/** Compute CRC-32 used by PNG chunks \\(ISO 3309 / ITU-T V.42\\). */\nfunction crc32\\(buf\\) {\n  // Build table once\n  if \\(!crc32._table\\) {\n    const table = new Uint32Array\\(256\\);\n    for \\(let n = 0; n < 256; n++\\) {\n      let c = n;\n      for \\(let k = 0; k < 8; k++\\) {\n        c = c & 1 ? 0xedb88320 ^ \\(c >>> 1\\) : c >>> 1;\n      }\n      table[n] = c;\n    }\n    crc32._table = table;\n  }\n  const table = crc32._table;\n  let crc = 0xffffffff;\n  for \\(let i = 0; i < buf.length; i++\\) {\n    crc = table[\\(crc ^ buf[i]\\) & 0xff] ^ \\(crc >>> 8\\);\n  }\n  return \\(crc ^ 0xffffffff\\) >>> 0; // unsigned 32-bit\n}\n\n/** Build a single PNG chunk \\(type is a 4-char string, data is a Buffer\\). */\nfunction makeChunk\\(type, data\\) {\n  const typeBuffer = Buffer.from\\(type, 'ascii'\\);\n  const length = Buffer.alloc\\(4\\);\n  length.writeUInt32BE\\(data.length, 0\\);\n\n  const crcInput = Buffer.concat\\([typeBuffer, data]\\);\n  const crcValue = crc32\\(crcInput\\);\n  const crcBuffer = Buffer.alloc\\(4\\);\n  crcBuffer.writeUInt32BE\\(crcValue, 0\\);\n\n  return Buffer.concat\\([length, typeBuffer, data, crcBuffer]\\);\n}\n\n/** Generate a minimal valid PNG buffer for a solid-colour rectangle. */\nfunction generatePNG\\(width, height\\) {\n  // ── 1. PNG signature ──\n  const signature = Buffer.from\\([137, 80, 78, 71, 13, 10, 26, 10]\\);\n\n  // ── 2. IHDR ──\n  const ihdr = Buffer.alloc\\(13\\);\n  ihdr.writeUInt32BE\\(width, 0\\);   // width\n  ihdr.writeUInt32BE\\(height, 4\\);  // height\n  ihdr[8] = 8;                    // bit depth\n  ihdr[9] = 2;                    // colour type: RGB\n  ihdr[10] = 0;                   // compression method\n  ihdr[11] = 0;                   // filter method\n  ihdr[12] = 0;                   // interlace method\n  const ihdrChunk = makeChunk\\('IHDR', ihdr\\);\n\n  // ── 3. Raw image data \\(filter byte 0 + RGB triplets per row\\) ──\n  //    Each scanline: 1 filter-byte \\(0 = None\\) + width * 3 bytes \\(RGB\\)\n  const rowBytes = 1 + width * 3;\n  const raw = Buffer.alloc\\(rowBytes * height\\);\n\n  for \\(let y = 0; y < height; y++\\) {\n    const offset = y * rowBytes;\n    raw[offset] = 0; // filter type: None\n    for \\(let x = 0; x < width; x++\\) {\n      const px = offset + 1 + x * 3;\n      raw[px] = R;\n      raw[px + 1] = G;\n      raw[px + 2] = B;\n    }\n  }\n\n  const compressed = zlib.deflateSync\\(raw, { level: 9 }\\);\n  const idatChunk = makeChunk\\('IDAT', compressed\\);\n\n  // ── 4. IEND ──\n  const iendChunk = makeChunk\\('IEND', Buffer.alloc\\(0\\)\\);\n\n  return Buffer.concat\\([signature, ihdrChunk, idatChunk, iendChunk]\\);\n}\n\n// ── main ─────────────────────────────────────────────────────────────\n\nconst ROOT = path.resolve\\(__dirname, '..'\\);\nconst iconsDir = path.join\\(ROOT, 'public', 'icons'\\);\n\n// Ensure the icons directory exists\nfs.mkdirSync\\(iconsDir, { recursive: true }\\);\n\nconst icons = [\n  { name: 'icon-16.png',  w: 16,   h: 16 },\n  { name: 'icon-32.png',  w: 32,   h: 32 },\n  { name: 'icon-180.png', w: 180,  h: 180 },\n  { name: 'icon-192.png', w: 192,  h: 192 },\n  { name: 'icon-512.png', w: 512,  h: 512 },\n  { name: 'og-image.png', w: 1200, h: 630 },\n];\n\nfor \\(const icon of icons\\) {\n  const filePath = path.join\\(iconsDir, icon.name\\);\n  const png = generatePNG\\(icon.w, icon.h\\);\n  fs.writeFileSync\\(filePath, png\\);\n  console.log\\('  created  ' + path.relative\\(ROOT, filePath\\) + '  \\(' + icon.w + 'x' + icon.h + ', ' + png.length + ' bytes\\)'\\);\n}\n\n// favicon.ico - copy the 32x32 PNG \\(modern browsers accept PNG favicons\\)\nconst src32 = path.join\\(iconsDir, 'icon-32.png'\\);\nconst favicon = path.join\\(ROOT, 'public', 'favicon.ico'\\);\nfs.copyFileSync\\(src32, favicon\\);\nconsole.log\\('  created  ' + path.relative\\(ROOT, favicon\\) + '  \\(copy of icon-32.png\\)'\\);\n\nconsole.log\\('\\\\nAll icons generated successfully.'\\);\nENDOFSCRIPT)",
      "Bash(timeout 15 npm run dev:*)",
      "Bash(npm run dev:*)",
      "Bash(git push:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(vercel domains add:*)"
    ]
  }
}
